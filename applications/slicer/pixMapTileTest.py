import sys
import time
import numpy as np
import time

import pixmaptest

"""
	Test Tiling and various pixel filling algos
"""

"a base array for copying"
base   = np.array([[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], \
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]] );

"the boundary of a fake contrived object"		
boundary   = np.array([[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], \
					[0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0],\
					[0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0],\
					[0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0],\
					[0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,0],\
					[0,4,0,0,0,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,4,0],\
					[0,4,0,0,4,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,4,0],\
					[0,4,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,4,0],\
					[0,4,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,4,0],\
					[0,4,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,4,0],\
					[0,4,0,0,4,4,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,4,0],\
					[0,4,0,0,0,0,4,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,4,0],\
					[0,4,0,0,0,0,4,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,4,0],\
					[0,4,0,0,0,0,4,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,4,0],\
					[0,4,0,0,0,0,0,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,4,0],\
					[0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0],\
					[0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0],\
					[0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0],\
					[0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0],\
					[0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0],\
					[0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0],\
					[0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0],\
					[0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0],\
					[0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0],\
					[0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0],\
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]] );

"the inside fill of a fake test object"
filling   = np.array([[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], \
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\
					[0,0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,0,0,0,0,0],\
					[0,0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,0,0,0,0],\
					[0,0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,0,0,0],\
					[0,0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,0,0],\
					[0,0,7,7,7,7,0,0,0,0,0,0,0,0,0,7,7,7,7,7,7,7,0,0],\
					[0,0,7,7,7,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,7,7,0,0],\
					[0,0,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,7,0,0],\
					[0,0,7,7,7,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,7,7,0,0],\
					[0,0,7,7,7,7,7,0,0,0,0,0,0,0,0,7,7,7,7,7,7,7,0,0],\
					[0,0,7,7,7,7,7,7,0,0,0,0,0,0,0,7,7,7,7,7,7,7,0,0],\
					[0,0,7,7,7,7,7,7,0,0,0,0,0,0,7,7,7,7,7,7,7,7,0,0],\
					[0,0,7,7,7,7,7,7,0,0,0,0,0,0,7,7,7,7,7,7,7,7,0,0],\
					[0,0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,0,0],\
					[0,0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,0,0],\
					[0,0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,0,0],\
					[0,0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,0,0],\
					[0,0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,0,0],\
					[0,0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,0,0],\
					[0,0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,0,0],\
					[0,0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,0,0],\
					[0,0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,0,0],\
					[0,0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,0,0],\
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]] );

#a small hex tile					
hextile = np.array([[1,2,0,0,0,0,0,0,2,1], \
					 [0,0,1,0,0,0,0,1,0,0], \
					 [0,0,1,0,0,0,0,1,0,0], \
					 [0,0,0,2,1,1,2,0,0,0], \
					 [0,0,0,2,1,1,2,0,0,0], \
					 [0,0,1,0,0,0,0,1,0,0], \
					 [0,0,1,0,0,0,0,1,0,0], \
					 [1,2,0,0,0,0,0,0,2,1]] );

def readRow(array,y,xstart,xstep ):
	"returns the largest number of non-zero cells in a row on the row y"
	(xmax,ymax) = array.shape;
	x = xstart;
	while x < xmax and array[x,y] != 0:
		array[x,y] = 0;
		x += xstep;
	#array[xstart:x,y] = 0;
	return x;

def readRow2(array,y,xstart,xstep):
	"slightly smarter way to find a block of pixels"
	(xmax,ymax) = array.shape;
	t = array[xstart:,y];
	
	q = np.where(t == 1)[0];
	#print q
	xend = q[-1];
	t[0:xend] = 0;
	#print xstart,xend;
	return (xstart,xend);
	
def findFirstUnfilled(array):
	"return the nearest unfilled spot from the currrent point"
	"this can be done with numpy trickery"
	
	(xind,yind) = np.where(array > 0 );
	print "Unfilled pix: %d " % len(xind)
	if len(xind) > 0:
		#print xind[0],yind[0]
		return ( xind[0],yind[0] );
	else:
		return None;

def findPathsVeryDumbly(array):
	"""
	   given a starting point, try to fill a canvas with line segments
	   return a list of line segments, from begin to end point
	   
	   This version attempts to scan left and right, drawing diagonals as required
	"""
	lines = [];
	xstep=1;

	f  = findFirstUnfilled(array);
	rrt = 0;
	uft = 0;
	while f != None:
		#read current row all the way to the right
		(x0,y0) = f;
		q = time.clock();
		xend = readRow2(array,y0,x0,xstep);
		
		r=  ( time.clock() - q );
		print rrt;
		rrt += r;
		lines.append( [(x0,y0), (xend,y0) ] );
		#print "paths: %d" % len(lines)
		q = time.clock();
		f = findFirstUnfilled(array);
		uft +=( time.clock() - q );
		
	print rrt,uft
	return lines;
		

if __name__=='__main__':
	#tile to the shape of the overall
	(hl, hw ) = hextile.shape;

	(bl, bw ) = boundary.shape;
	numwide = round(bw / hw ) + 1;
	numtall = round(bl / hl ) + 1;

	hexpattern = np.tile(hextile,(numtall,numwide));
	hexpattern = hexpattern[:bl,:bw];

	#print boundary;
	#print filling;
	#print hexpattern;
	q = time.clock();
	#compute 
	p = findPathsVeryDumbly(filling);
	print "Found %d paths." % len(p);

	#print((hexpattern & filling ) +   boundary);
	print "elapsed %0.3f" % (time.clock() - q );

